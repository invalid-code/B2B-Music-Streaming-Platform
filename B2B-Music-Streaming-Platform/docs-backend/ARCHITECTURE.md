# How Our App is Built - Architecture Overview

Hey! This doc explains how the B2B Music Streaming Platform is structured. Think of it like the blueprint for our app. I'll break it down into simple layers and show how everything connects.

## The Layered Approach

Our app follows a clean layered architecture, which means we separate different responsibilities. Here's how it looks:
?  ? PlaylistsCtrl    ?  ? TracksCtrl       ?  ? VenuesCtrl   ??
?  ? /api/playlists   ?  ? /api/tracks      ?  ? /api/venues  ??
?  ????????????????????  ????????????????????  ?????????????????
?????????????????????????????????????????????????????????????????
            ?                      ?                    ?
?????????????????????????????????????????????????????????????????
?                      Service Layer                            ?
?  ????????????????????  ????????????????????  ?????????????????
?  ?PlaylistService   ?  ?TrackService      ?  ?VenueService  ??
?  ?(IPlaylistService)?  ?(ITrackService)   ?  ?(IVenueService)??
?  ?- GetAll()        ?  ?- GetAll()        ?  ?- GetAll()    ??
?  ?- GetById()       ?  ?- GetById()       ?  ?- GetById()   ??
?  ?- Create()        ?  ?- Create()        ?  ?- Create()    ??
?  ?- Update()        ?  ?- Update()        ?  ?- Update()    ??
?  ?- Delete()        ?  ?- Delete()        ?  ?- Delete()    ??
?  ????????????????????  ????????????????????  ?????????????????
?????????????????????????????????????????????????????????????????
            ?                      ?                    ?
?????????????????????????????????????????????????????????????????
?                    Repository Layer                           ?
?  ????????????????????  ????????????????????  ?????????????????
?  ?PlaylistRepository?  ?TrackRepository   ?  ?VenueRepository??
?  ?(Interface)       ?  ?(Interface)       ?  ?(Interface)   ??
?  ????????????????????  ????????????????????  ?????????????????
?           ?                     ?                    ?       ?
?  ????????????????????????????????????????????????????????????
?  ?  GenericRepository<T> (Base Implementation)            ??
?  ?  - GetById()  - GetAll()  - Add()  - Update() - Delete()??
?  ??????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????
            ?
??????????????????????????????????????????????????????????????
?                   Data Layer                               ?
?  ???????????????????????????????????????????????????????????
?  ? In-Memory Store (Current)                              ??
?  ? List<T> _data                                          ??
?  ?                                                        ??
?  ? OR                                                     ??
?  ?                                                        ??
?  ? Database (Future - Entity Framework Core)             ??
?  ? ApplicationDbContext + SQL Server/PostgreSQL           ??
?  ???????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????
```

### Why Layers Matter

- **API Layer**: This is where HTTP requests come in. Controllers handle the web requests and talk to the services below.
- **Service Layer**: The business logic lives here. Services decide what to do with data and enforce rules.
- **Repository Layer**: This handles data storage and retrieval. Right now it's just in-memory, but we'll add a real database later.
- **Data Layer**: Where the actual data is stored. Currently using simple lists, but will be a proper database.

## How Data Flows Through the System

Let's walk through what happens when someone creates a playlist. It's like a journey through all the layers:

```
1. HTTP Request comes in
   POST /api/playlists
   {
     "name": "Jazz Vibes",
     "vibeOrGenre": "Jazz",
     "trackIDs": ["track1", "track2"]
   }
   ?
   ?
2. PlaylistsController.CreatePlaylist() gets it
   - Checks if the data looks right
   - Asks the playlist service to create it
   ?
   ?
3. PlaylistService.CreatePlaylistAsync() does the work
   - Makes a new Playlist object
   - Gives it a unique ID and timestamp
   - Tells the repository to save it
   ?
   ?
4. PlaylistRepository.AddAsync() saves it
   - Adds the playlist to our in-memory list
   - Sends it back
   ?
   ?
5. Service turns it into a response
   - Converts the internal data to what the API should return
   - Sends back a clean response
   ?
   ?
6. Controller sends the HTTP response
   - Returns 201 Created
   - Includes the new playlist data
   - Points to where to find it
   ?
   ?
7. Client gets the response
   201 Created
   {
     "playlistID": "abc123def456",
     "name": "Jazz Vibes",
     "vibeOrGenre": "Jazz",
     "trackIDs": ["track1", "track2"]
   }
```

Pretty straightforward, right? Each layer has one job and talks to the layer next to it.

## How We Wire Everything Together

We use dependency injection to connect all these pieces. It's like plugging Lego bricks together:
   201 Created
   Location: /api/playlists/abc123def456
   {
     "playlistID": "abc123def456",
     "name": "Jazz Vibes",
     "vibeOrGenre": "Jazz",
     "trackIDs": ["track1", "track2"]
   }
```

## How We Wire Everything Together

We use dependency injection to connect all these pieces. It's like plugging Lego bricks together:

```
Program.cs Configuration
?
?? Repositories (Scoped Lifetime)
?  ?? IPlaylistRepository ? PlaylistRepository
?  ?? ITrackRepository ? TrackRepository
?  ?? IVenueRepository ? VenueRepository
?
?? Services (Scoped Lifetime)
?  ?? IPlaylistService ? PlaylistService
?  ?   ?? Depends on: IPlaylistRepository
?  ?? ITrackService ? TrackService
?  ?   ?? Depends on: ITrackRepository
?  ?? IVenueService ? VenueService
?      ?? Depends on: IVenueRepository
?
?? Controllers (Created per request)
   ?? PlaylistsController
   ?   ?? Injected with: IPlaylistService
   ?? TracksController
   ?   ?? Injected with: ITrackService
   ?? VenuesController
       ?? Injected with: IVenueService
```

This way, everything is loosely connected and easy to test or change.

## Our Data Model

Here's how the main things in our app relate to each other:

```
???????????????????
?   Playlist      ?
???????????????????
? PlaylistID (PK) ?
? Name            ? ??????
? VibeOrGenre     ?      ? References
? TrackIDs[] ??????????????????????????????
? CreatedAt       ?      ?                ?
???????????????????      ?                ?
                         ?                ?
                    ????????????????????? ?
                    ?   Track           ? ?
                    ????????????????????? ?
                    ? TrackID (PK) ?????? ?
                    ? Title             ? ?
                    ? Artist            ? ?
                    ? Mood              ? ?
                    ? CloudflareStorageKey?
                    ? UploadedAt        ? ?
                    ????????????????????? ?
                                         ?
            ??????????????????????????????
            ?
            ? (Many-to-Many through TrackIDs list)
            ?
????????????????????????????
?   Venue                  ?
????????????????????????????
? VenueID (PK)             ?
? BusinessName             ?
? Location                 ?
? SubscriptionStatus       ?
? (Trial/Paid)             ?
?                          ?
? Subtypes:                ?
? - TrialVenue             ?
?   CheckStreamLimit <= 30 min
?                          ?
? - PaidVenue              ?
?   CheckStreamLimit unlimited
????????????????????????????
```

Playlists can have many tracks, and tracks can be in many playlists. Venues are separate and have different limits based on their subscription.

## Keeping API Responses Clean

We don't send raw database data to the client. Instead, we map it to clean response objects:

```
Entity (Database Model)          DTO (API Response)
????????????????????           ????????????????????
? Playlist         ?           ? PlaylistResponse ?
????????????????????           ????????????????????
? PlaylistID       ??????????  ? PlaylistID       ?
? Name             ??????????  ? Name             ?
? VibeOrGenre      ??????????  ? VibeOrGenre      ?
? TrackIDs[]       ??????????  ? TrackIDs[]       ?
? CreatedAt        ?           ? (Not included)   ?
? (Internal field) ?           ?                  ?
????????????????????           ????????????????????

Why this is smart:
- Clients don't see internal details
- We can change storage without breaking the API
- Keeps the external interface stable
```

## Handling Errors Gracefully

When things go wrong, we have a clear path to handle it:

```
Request
  ?
  ?
Controller
  ?
  ??? ModelState Invalid? ??? 400 Bad Request
  ?
  ?
Service
  ?
  ??? Business Logic Error? ??? Return false/null
  ?
  ?
Repository
  ?
  ??? Entity not found? ??? Null return
  ?
  ?
Controller
  ?
  ??? Null response? ??? 404 Not Found
  ??? False result? ??? 404 Not Found
  ??? Success? ??? 200/201/204 OK
  ?
  ?
```

This keeps errors consistent and helps clients know what went wrong.

That's the basic architecture! It's designed to be simple now but ready to grow. We can easily add a real database, more features, or scale it up later.
```
